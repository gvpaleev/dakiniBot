import { SessionContext } from 'telegraf/src/session';
import SceneContextScene, { SceneContextSceneOptions, SceneSession, SceneSessionData } from 'telegraf/src/scenes/context';
import { BaseScene } from 'telegraf/src/scenes/base';
import { Composer } from 'telegraf/src/composer';
import { Context } from 'telegraf/src/context';
export declare class Stage<C extends SessionContext<SceneSession<D>> & {
    scene: SceneContextScene<C, D>;
}, D extends SceneSessionData = SceneSessionData> extends Composer<C> {
    options: Partial<SceneContextSceneOptions<D>>;
    scenes: Map<string, BaseScene<C>>;
    constructor(scenes?: ReadonlyArray<BaseScene<C>>, options?: Partial<SceneContextSceneOptions<D>>);
    register(...scenes: ReadonlyArray<BaseScene<C>>): this;
    middleware(): import("telegraf/src/middleware").MiddlewareFn<C>;
    static enter<C extends Context & {
        scene: SceneContextScene<C>;
    }>(...args: Parameters<SceneContextScene<C>['enter']>): (ctx: C) => Promise<unknown>;
    static reenter<C extends Context & {
        scene: SceneContextScene<C>;
    }>(...args: Parameters<SceneContextScene<C>['reenter']>): (ctx: C) => Promise<unknown> | undefined;
    static leave<C extends Context & {
        scene: SceneContextScene<C>;
    }>(...args: Parameters<SceneContextScene<C>['leave']>): (ctx: C) => Promise<void>;
}
//# sourceMappingURL=stage.d.ts.map